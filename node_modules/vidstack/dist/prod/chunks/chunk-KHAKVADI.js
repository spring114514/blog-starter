import { AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunk-FRNAFKFA.js';
import { isHLSSupported, IS_SAFARI, canPlayHLSNatively } from './chunk-WSYKLWQE.js';
import { TextTrack } from './chunk-IIULWXWS.js';
import { getRequestCredentials, preconnect } from './chunk-IVW6GMZV.js';
import { scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { signal, onDispose, peek, computed, effect, tick } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { animationFrameThrottle, listenEvent, setStyle, isString, isArray } from 'maverick.js/std';
import { $$_create_walker, $$_effect, $$_attr, $$_ref, $$_create_template } from 'maverick.js/dom';

var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><audio preload="none" aria-hidden="true"></audio>`);
var $$_templ_2 = $$_templ;
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    return new (await import('./provider-KHKJ2PBP.js')).AudioProvider(this.Qd);
  }
  render($store) {
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_ref($$_root, (el) => void (this.Qd = el));
      return $$_root;
    })();
  }
};
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<!$><video preload="none" aria-hidden="true"></video>`);
var $$_templ_22 = $$_templ2;
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    return new (await import('./provider-BAHBXXOB.js')).VideoProvider(this.k, context);
  }
  render($store) {
    const $poster = computed(() => $store.poster() && $store.controls() ? $store.poster() : null);
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_22);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_effect(() => $$_attr($$_root, "poster", $poster()));
      $$_ref($$_root, (el) => void (this.k = el));
      return $$_root;
    })();
  }
};

// src/player/core/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    return new (await import('./provider-CPPRUF2Z.js')).HLSProvider(this.k, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/core/outlet/source-select.ts
var SourceSelection = class {
  constructor(_domSources, _media, _loader) {
    this.wb = _domSources;
    this.a = _media;
    this.Ja = _loader;
    const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
    this.Rd = computed(() => {
      return _media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
    });
    effect(this.lg.bind(this));
    effect(this.mg.bind(this));
    effect(this.ng.bind(this));
    effect(this.og.bind(this));
  }
  lg() {
    this.a.delegate.d("sources-change", {
      detail: [...normalizeSrc(this.a.$props.src()), ...this.wb()]
    });
  }
  mg() {
    const { $store } = this.a;
    const sources = $store.sources(), currentSource = peek($store.source), newSource = this.Sd(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
    if (noMatch) {
      const { crossorigin } = $store, credentials = getRequestCredentials(crossorigin()), abort = new AbortController();
      Promise.all(
        sources.map(
          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
            method: "HEAD",
            credentials,
            signal: abort.signal
          }).then((res) => {
            source.type = res.headers.get("content-type") || "??";
            return source;
          }).catch(() => source) : source
        )
      ).then((sources2) => {
        if (abort.signal.aborted)
          return;
        this.Sd(peek($store.source), sources2);
        tick();
      });
      return () => abort.abort();
    }
    tick();
  }
  Sd(currentSource, sources) {
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek(this.Rd).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    this.pg(currentSource, newSource, newLoader);
    this.qg(peek(this.Ja), newLoader);
    return newSource;
  }
  pg(currentSource, newSource, newLoader) {
    if (newSource.src === currentSource.src && newSource.type === currentSource.type)
      return;
    this.a.delegate.d("source-change", { detail: newSource });
    this.a.delegate.d("media-type-change", {
      detail: newLoader?.mediaType(newSource) || "unknown"
    });
  }
  qg(currentLoader, newLoader) {
    if (newLoader === currentLoader)
      return;
    this.a.delegate.d("provider-change", { detail: null });
    newLoader && peek(() => newLoader.preconnect?.(this.a));
    this.Ja.set(newLoader);
    this.a.delegate.d("provider-loader-change", { detail: newLoader });
  }
  ng() {
    const provider = this.a.$provider();
    if (!provider)
      return;
    if (this.a.$store.canLoad()) {
      peek(
        () => provider.setup({
          ...this.a,
          player: this.a.player
        })
      );
      return;
    }
    peek(() => provider.preconnect?.(this.a));
  }
  og() {
    const provider = this.a.$provider(), source = this.a.$store.source();
    if (this.a.$store.canLoad()) {
      peek(() => provider?.loadSource(source, peek(this.a.$store.preload)));
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
    }
  }
};
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}
var Tracks = class {
  constructor(_domTracks, _media) {
    this.xb = _domTracks;
    this.a = _media;
    this.Td = [];
    effect(this.rg.bind(this));
  }
  rg() {
    const newTracks = [...this.a.$props.textTracks(), ...this.xb()];
    for (const newTrack of newTracks) {
      const id = newTrack.id || TextTrack.createId(newTrack);
      if (!this.a.textTracks.getById(id)) {
        newTrack.id = id;
        this.a.textTracks.add(newTrack);
      }
    }
    for (const oldTrack of this.Td) {
      if (!newTracks.some((t) => t.id === oldTrack.id)) {
        const track = oldTrack.id && this.a.textTracks.getById(oldTrack.id);
        if (track)
          this.a.textTracks.remove(track);
      }
    }
    this.Td = newTracks;
  }
};

// src/player/core/outlet/outlet.tsx
var Outlet = class extends Component {
  constructor(instance) {
    super(instance);
    this.wb = signal([]);
    this.xb = signal([]);
    this.Ja = signal(null);
    this.a = useMedia();
    new SourceSelection(this.wb, this.a, this.Ja);
    new Tracks(this.xb, this.a);
  }
  onAttach(el) {
    el.setAttribute("keep-alive", "");
  }
  onConnect(el) {
    const resize = new ResizeObserver(animationFrameThrottle(this.F.bind(this)));
    resize.observe(el);
    const mutation = new MutationObserver(this.yb.bind(this));
    mutation.observe(el, { attributes: true, childList: true });
    if (IS_SAFARI) {
      listenEvent(el, "touchstart", (e) => e.preventDefault(), { passive: false });
    }
    scopedRaf(() => {
      this.F();
      this.yb();
    });
    return () => {
      resize.disconnect();
      mutation.disconnect();
    };
  }
  onDestroy() {
    this.a.$store.currentTime.set(0);
  }
  F() {
    const player = this.a.player, width = this.el.offsetWidth, height = this.el.offsetHeight;
    if (!player)
      return;
    player.$store.mediaWidth.set(width);
    player.$store.mediaHeight.set(height);
    setStyle(player, "--media-width", width + "px");
    setStyle(player, "--media-height", height + "px");
  }
  yb() {
    const sources = [], tracks = [], children = this.el.children;
    for (const el of children) {
      if (el instanceof HTMLSourceElement) {
        sources.push({
          src: el.src,
          type: el.type
        });
      } else if (el instanceof HTMLTrackElement) {
        tracks.push({
          id: el.id,
          src: el.src,
          kind: el.track.kind,
          language: el.srclang,
          label: el.label,
          default: el.default,
          type: el.getAttribute("data-type")
        });
      }
    }
    this.wb.set(sources);
    this.xb.set(tracks);
  }
  render() {
    let currentProvider;
    onDispose(() => currentProvider?.destroy?.());
    return () => {
      currentProvider?.destroy();
      const loader = this.Ja();
      if (!loader)
        return null;
      const el = loader.render(this.a.$store);
      peek(() => {
        loader.load(this.a).then((provider) => {
          if (peek(this.Ja) !== loader)
            return;
          this.a.delegate.d("provider-change", {
            detail: provider
          });
          currentProvider = provider;
        });
      });
      return el;
    };
  }
};
Outlet.el = defineElement({
  tagName: "media-outlet"
});

export { Outlet };
