import { scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { effect, peek } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { listenEvent, isPointerEvent, isMouseEvent, isTouchEvent, kebabToCamelCase } from 'maverick.js/std';

var Gesture = class extends Component {
  constructor() {
    super(...arguments);
    this.Ka = null;
    this.wa = 0;
    this.re = -1;
  }
  onAttach() {
    const { event, action } = this.$props;
    this.setAttributes({
      event,
      action
    });
  }
  onConnect() {
    this.a = useMedia();
    scopedRaf(() => {
      this.Ka = this.a.player.querySelector("media-outlet");
      effect(this.Hh.bind(this));
    });
  }
  Hh() {
    let eventType = this.$props.event();
    if (!this.Ka || !eventType)
      return;
    if (/^dbl/.test(eventType)) {
      eventType = eventType.split(/^dbl/)[1];
    }
    listenEvent(this.Ka, eventType, this.Ih.bind(this));
  }
  Ih(event) {
    if (!this.Jh(event) || isPointerEvent(event) && event.button !== 0)
      return;
    event.MEDIA_GESTURE = true;
    event.preventDefault();
    const isDblEvent = peek(this.$props.event)?.startsWith("dbl");
    if (!isDblEvent) {
      if (this.wa === 0) {
        setTimeout(() => {
          if (this.wa === 1)
            this.se(event);
        }, 250);
      }
    } else if (this.wa === 1) {
      queueMicrotask(() => this.se(event));
      clearTimeout(this.re);
      this.wa = 0;
      return;
    }
    if (this.wa === 0) {
      this.re = window.setTimeout(() => {
        this.wa = 0;
      }, 275);
    }
    this.wa++;
  }
  se(event) {
    this.el.setAttribute("data-triggered", "");
    requestAnimationFrame(() => {
      if (this.Kh()) {
        this.Lh(peek(this.$props.action), event);
      }
      requestAnimationFrame(() => {
        this.el.removeAttribute("data-triggered");
      });
    });
  }
  /** Validate event occurred in gesture bounds. */
  Jh(event) {
    if (!this.el)
      return false;
    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
      const touch = isTouchEvent(event) ? event.touches[0] : void 0;
      const clientX = touch?.clientX ?? event.clientX;
      const clientY = touch?.clientY ?? event.clientY;
      const rect = this.el.getBoundingClientRect();
      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
      return event.type.includes("leave") ? !inBounds : inBounds;
    }
    return true;
  }
  /** Validate gesture has the highest z-index in this triggered group. */
  Kh() {
    const gestures = this.a.player.querySelectorAll(
      "media-gesture[data-triggered]"
    );
    return Array.from(gestures).sort(
      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
    )[0]?.component === this;
  }
  Lh(action, trigger) {
    if (!action)
      return;
    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
    if (action.includes(":fullscreen")) {
      this.a.remote.toggleFullscreen("prefer-media", trigger);
    } else if (action.includes("seek:")) {
      this.a.remote.seek(peek(this.a.$store.currentTime) + (+value || 0), trigger);
    } else {
      this.a.remote[kebabToCamelCase(method)](trigger);
    }
  }
};
Gesture.el = defineElement({
  tagName: "media-gesture",
  props: {
    event: void 0,
    action: void 0
  }
});

export { Gesture };
