import { findActiveCue } from './chunk-NOPW2CG3.js';
import { $ariaBool } from './chunk-EVP5E6AO.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { $$_create_walker, $$_effect, $$_attr, $$_listen, $$_ref, $$_create_template } from 'maverick.js/dom';
import { signal, effect, peek } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { animationFrameThrottle } from 'maverick.js/std';

var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><img part="img" loading="eager" decoding="async" aria-hidden="true" />`);
var Thumbnail = class extends Component {
  constructor(instance) {
    super(instance);
    this.qa = null;
    this.Bb = null;
    this.yc = [];
    this.da = signal("");
    this.zc = signal(false);
    this.Ac = signal(null);
    this.ae = animationFrameThrottle(this.Sg.bind(this));
    this.a = useMedia();
  }
  onAttach() {
    this.setAttributes({
      "data-loading": this.Bc.bind(this),
      "aria-hidden": $ariaBool(this.z.bind(this))
    });
  }
  onConnect() {
    effect(this.ia.bind(this));
    effect(this.Ng.bind(this));
    effect(this.Og.bind(this));
  }
  ia() {
    this.da();
    this.a.$store.thumbnails();
    this.zc.set(false);
  }
  Yb() {
    this.zc.set(true);
    this.ae();
  }
  Bc() {
    return !this.z() && !this.zc();
  }
  z() {
    const { duration, thumbnailCues } = this.a.$store;
    return !Number.isFinite(duration()) || thumbnailCues().length === 0;
  }
  Ng() {
    const { time } = this.$props, { duration, thumbnailCues } = this.a.$store, _cues = thumbnailCues(), _time = time();
    if (!_cues || !Number.isFinite(duration())) {
      this.Ac.set(null);
      return;
    }
    this.Ac.set(findActiveCue(_time, _cues));
  }
  Pg(el) {
    this.qa = el;
  }
  Og() {
    const activeCue = this.Ac(), thumbnails = peek(this.a.$store.thumbnails);
    if (!thumbnails || !activeCue) {
      this.da.set("");
      this.be();
      return;
    }
    const [_src, _coords = ""] = (activeCue.text || "").split("#");
    this.Bb = this.Qg(_coords);
    if (!this.Bb) {
      this.be();
      return;
    }
    this.da.set(this.Rg(thumbnails, _src));
    this.ae();
  }
  Rg(baseURL, src) {
    return !/https?:/.test(src) ? `${baseURL.split("/").slice(0, -1).join("/")}${src.replace(/^\/?/, "/")}`.replace(
      /^\/\//,
      "/"
    ) : src;
  }
  Qg(coords) {
    const [props, values] = coords.split("="), resolvedCoords = {}, coordValues = values.split(",");
    if (!props || !values)
      return null;
    for (let i = 0; i < props.length; i++)
      resolvedCoords[props[i]] = +coordValues[i];
    return resolvedCoords;
  }
  Sg() {
    if (!this.qa || !this.Bb || !this.el)
      return;
    const { w, h, x, y } = this.Bb, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(this.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
    this.cb(this.el, "--thumbnail-width", `${w * scale}px`);
    this.cb(this.el, "--thumbnail-height", `${h * scale}px`);
    this.cb(this.qa, "width", `${this.qa.naturalWidth * scale}px`);
    this.cb(this.qa, "height", `${this.qa.naturalHeight * scale}px`);
    this.cb(this.qa, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
  }
  cb(el, name, value) {
    el.style.setProperty(name, value);
    this.yc.push(() => el.style.removeProperty(name));
  }
  be() {
    for (const reset of this.yc)
      reset();
    this.yc = [];
  }
  render() {
    const { crossorigin } = this.a.$store;
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ);
      $$_effect(() => $$_attr($$_root, "src", this.da()));
      $$_effect(() => $$_attr($$_root, "crossorigin", crossorigin()));
      $$_listen($$_root, "load", this.Yb.bind(this));
      $$_ref($$_root, this.Pg.bind(this));
      return $$_root;
    })();
  }
};
Thumbnail.el = defineElement({
  tagName: "media-thumbnail",
  props: { time: 0 }
});

export { Thumbnail };
