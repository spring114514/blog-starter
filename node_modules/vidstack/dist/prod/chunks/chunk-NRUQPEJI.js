import { $ariaBool } from './chunk-EVP5E6AO.js';
import { onPress, setAttributeIfEmpty, isElementParent } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { menuContext } from './chunk-HSL7QSWM.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { signal, hasProvidedContext, useContext, provideContext, effect, scoped, peek, tick, onDispose } from 'maverick.js';
import { defineElement, method, Component } from 'maverick.js/element';
import { setAttribute, listenEvent, ariaBool, isKeyboardEvent, setStyle } from 'maverick.js/std';

var FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
  "a[href]",
  "[tabindex]",
  "input",
  "select",
  "button"
].map((selector) => `${selector}:not([aria-hidden])`).join(",");
var VALID_KEYS = /* @__PURE__ */ new Set([
  "Escape",
  "Tab",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "PageUp",
  "End",
  "PageDown",
  "Enter",
  " "
]);
var MenuFocusController = class {
  constructor(_closeMenu) {
    this.qh = _closeMenu;
    this.W = 0;
    this.ra = null;
    this.R = [];
  }
  get q() {
    return this.R;
  }
  nh(el) {
    listenEvent(el, "focus", this.Sa.bind(this));
    this.ra = el;
  }
  oh() {
    if (!this.ra)
      return;
    this.T();
    listenEvent(this.ra, "keyup", this.Ya.bind(this));
    listenEvent(this.ra, "keydown", this.Za.bind(this));
    onDispose(() => {
      this.W = 0;
      this.R = [];
    });
  }
  Na(index) {
    this.W = index;
    this.R[index]?.focus();
    this.R[index]?.scrollIntoView({
      block: "center"
    });
  }
  Sa() {
    const index = this.R.findIndex((el) => el.getAttribute("aria-checked") === "true");
    this.Na(index >= 0 ? index : 0);
  }
  T() {
    this.W = 0;
    this.R = this.ph();
  }
  Ya(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
  }
  Za(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
    switch (event.key) {
      case "Escape":
        this.qh(event);
        break;
      case "Tab":
        this.Na(this.Nc(event.shiftKey ? -1 : 1));
        break;
      case "ArrowUp":
        this.Na(this.Nc(-1));
        break;
      case "ArrowDown":
        this.Na(this.Nc(1));
        break;
      case "Home":
      case "PageUp":
        this.Na(0);
        break;
      case "End":
      case "PageDown":
        this.Na(this.R.length - 1);
        break;
    }
  }
  Nc(delta) {
    let index = this.W;
    do {
      index = (index + delta + this.R.length) % this.R.length;
    } while (this.R[index].offsetParent === null);
    return index;
  }
  ph() {
    if (!this.ra)
      return [];
    const focusableElements = this.ra.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
    const is = (node) => node.hasAttribute("data-media-menu-items");
    for (const el of focusableElements) {
      if (isElementParent(this.ra, el, is))
        elements.push(el);
    }
    return elements;
  }
};

// src/player/ui/menu/menu.tsx
var idCount = 0;
var Menu = class extends Component {
  constructor(instance) {
    super(instance);
    this.L = signal(false);
    this.he = signal(false);
    this.ie = signal(false);
    this.Eb = /* @__PURE__ */ new Set();
    this.Qc = null;
    this.s = null;
    this.ki = this.sa.bind(this);
    this.zh = this.Ah.bind(this);
    this.xh = this.Bh.bind(this);
    this.yh = this.Ch.bind(this);
    this.a = useMedia();
    const currentIdCount = ++idCount;
    this.Oc = `media-menu-${currentIdCount}`;
    this.Pc = `media-menu-button-${currentIdCount}`;
    if (hasProvidedContext(menuContext)) {
      this.X = useContext(menuContext);
    }
    this.Rc = new MenuFocusController(this.close.bind(this));
    provideContext(menuContext, {
      L: this.L,
      hb: signal(""),
      sa: this.sa.bind(this),
      Sc: this.Sc.bind(this),
      Tc: this.Tc.bind(this),
      Uc: this.Uc.bind(this),
      Vc: this.Vc.bind(this)
    });
  }
  onAttach(el) {
    const { position } = this.$props;
    this.setAttributes({
      position,
      "data-open": this.L,
      "data-submenu": !!this.X,
      "data-disabled": this.p.bind(this),
      "data-media-menu": true
    });
  }
  onConnect(el) {
    if (!this.X) {
      effect(this.je.bind(this));
    }
    effect(this.rh.bind(this));
    this.X?.Vc(el);
    requestAnimationFrame(() => this.F());
  }
  onDestroy() {
    this.ke();
    this.Qc = null;
    this.s = null;
  }
  ke() {
    if (!this.s || this.el?.contains(this.s))
      return;
    const menu = this.s?.parentElement;
    this.el.append(this.s);
    if (menu?.localName === "media-menu") {
      menu.destroy();
      menu.remove();
    }
  }
  je() {
    if (!this.el)
      return;
    const { breakpointX, breakpointY, viewType, orientation, fullscreen } = this.a.$store, popup = viewType() === "audio" ? breakpointX() === "sm" : breakpointY() === "sm";
    if (!this.s || this.X)
      return;
    setAttribute(this.el, "data-popup", popup);
    setAttribute(this.el, "data-popup-wide", popup && orientation() === "landscape");
    if (popup && !fullscreen()) {
      if (this.el.contains?.(this.s)) {
        const menu = this.el.cloneNode();
        menu.appendChild(this.s);
        scoped(() => {
          document.body.append(menu);
        }, this.a.scope);
      }
    }
    this.F();
    return () => this.ke();
  }
  rh() {
    const expanded = this.le();
    this.F();
    this.me(expanded);
    if (!expanded)
      return;
    this.Rc.oh();
    const closeTarget = this.sh();
    if (closeTarget) {
      onPress(closeTarget, this.th.bind(this));
    }
    this.listen("pointerup", this.uh.bind(this));
    listenEvent(window, "pointerup", this.vh.bind(this));
  }
  Sc(el) {
    const isMenuItem = !!this.X, isExpanded = this.le.bind(this), isARIAExpanded = $ariaBool(isExpanded), isARIADisabled = $ariaBool(this.p.bind(this));
    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
    setAttribute(el, "id", this.Pc);
    setAttribute(el, "aria-controls", this.Oc);
    setAttribute(el, "aria-haspopup", "true");
    effect(() => {
      setAttribute(el, "aria-disabled", isARIADisabled());
      setAttribute(el, "aria-expanded", isARIAExpanded());
      if (!isMenuItem)
        setAttribute(el, "aria-pressed", isARIAExpanded());
      setAttribute(el, "data-pressed", isExpanded());
    });
    setAttribute(el, "data-media-button", !isMenuItem);
    setAttribute(el, "data-media-menu-button", "");
    onPress(el, this.wh.bind(this));
    this.Qc = el;
  }
  Tc(el) {
    setAttributeIfEmpty(el, "role", "menu");
    setAttributeIfEmpty(el, "tabindex", "-1");
    setAttribute(el, "id", this.Oc);
    setAttribute(el, "aria-describedby", this.Pc);
    setAttribute(el, "data-media-menu-items", "");
    this.s = el;
    this.Rc.nh(el);
    this.je();
    this.me(peek(this.L));
  }
  me(expanded) {
    if (this.s)
      setAttribute(this.s, "aria-hidden", ariaBool(!expanded));
  }
  Uc(disabled) {
    this.ie.set(disabled);
  }
  wh(event) {
    if (this.X)
      event.stopPropagation();
    if (this.p())
      return;
    this.L.set((expanded) => !expanded);
    this.Wc();
    tick();
    if (isKeyboardEvent(event))
      this.s?.focus();
    this.o(event);
  }
  o(trigger) {
    this.dispatch(peek(this.L) ? "open" : "close", { trigger });
  }
  le() {
    return !this.p() && this.L();
  }
  p() {
    return this.he() || this.ie();
  }
  sa(disabled) {
    this.he.set(disabled);
  }
  uh(event) {
    event.stopPropagation();
  }
  vh() {
    if (this.X)
      return setTimeout(this.close.bind(this), 300);
    this.close();
  }
  th(event) {
    event.stopPropagation();
    this.close(event);
  }
  sh() {
    const target = this.el.querySelector('[slot="close-target"]');
    return isElementParent(this.el, target) ? target : null;
  }
  Wc(trigger) {
    if (this.X)
      return;
    if (this.L())
      this.a.remote.pauseUserIdle(trigger);
    else
      this.a.remote.resumeUserIdle(trigger);
  }
  Vc(el) {
    this.Eb.add(el);
    listenEvent(el, "open", this.xh);
    listenEvent(el, "close", this.yh);
    onDispose(this.zh);
  }
  Ah(el) {
    this.Eb.delete(el);
  }
  Bh(event) {
    for (const el of this.Eb) {
      if (el !== event.target)
        el.setAttribute("aria-hidden", "true");
    }
    this.F();
  }
  Ch() {
    for (const el of this.Eb)
      el.removeAttribute("aria-hidden");
    this.F();
  }
  F() {
    if (!this.s || false)
      return;
    let style = getComputedStyle(this.s), height = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let children = [...this.s.children];
    if (children[0]?.localName === "shadow-root") {
      children.push(...children[0].children);
    }
    for (const child of children) {
      height += child.offsetHeight;
    }
    requestAnimationFrame(() => {
      if (!this.s)
        return;
      setAttribute(this.s, "data-resizing", "");
      setTimeout(() => {
        if (!this.s)
          return;
        setAttribute(this.s, "data-resizing", false);
      }, 250);
      setStyle(this.s, "--menu-height", height + "px");
    });
  }
  open(trigger) {
    this.L.set(true);
    tick();
    this.o(trigger);
    if (isKeyboardEvent(trigger))
      this.s?.focus();
    this.Wc(trigger);
  }
  close(trigger) {
    this.L.set(false);
    tick();
    if (isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        this.Qc?.focus();
      });
    }
    this.o(trigger);
    this.Wc(trigger);
  }
};
Menu.el = defineElement({
  tagName: "media-menu",
  props: { position: null }
});
__decorateClass([
  method
], Menu.prototype, "open", 1);
__decorateClass([
  method
], Menu.prototype, "close", 1);

export { Menu };
