import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { round, clampNumber, getNumberOfDecimalPlaces } from './chunk-CVLY5S52.js';
import { IS_SAFARI } from './chunk-WSYKLWQE.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-VGM6UASR.js';
import { $$_create_walker, $$_effect, $$_attr, $$_next_element, $$_create_template } from 'maverick.js/dom';
import { provideContext, effect, peek } from 'maverick.js';
import { defineElement, Component, ComponentController } from 'maverick.js/element';
import { ariaBool, setStyle, listenEvent, isNull, isNumber, isDOMEvent, isKeyboardEvent, isUndefined } from 'maverick.js/std';

// src/player/ui/sliders/slider/api/props.ts
var sliderProps = {
  min: 0,
  max: 100,
  disabled: false,
  value: 100,
  step: 1,
  keyStep: 1,
  shiftKeyMultiplier: 5,
  trackClass: null,
  trackFillClass: null,
  trackProgressClass: null,
  thumbContainerClass: null,
  thumbClass: null
};

// src/player/ui/sliders/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/sliders/slider/events-controller.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
var SliderEventsController = class extends ComponentController {
  constructor(instance, _delegate, _media) {
    super(instance);
    this.g = _delegate;
    this.a = _media;
    this.Ka = null;
    this.oa = null;
    this.La = null;
    this.pa = null;
    this.Ma = null;
    this.Dg = functionThrottle(
      (event) => {
        this.ca(this.zb(event), event);
      },
      20,
      { leading: true }
    );
  }
  onConnect() {
    effect(this.vg.bind(this));
    effect(this.wg.bind(this));
    if (this.g.xg) {
      scopedRaf(() => {
        const outlet = this.a.player?.querySelector("media-outlet");
        if (outlet) {
          this.Ka = outlet;
          listenEvent(outlet, "touchstart", this.yg.bind(this));
          listenEvent(outlet, "touchmove", this.zg.bind(this));
        }
      });
    }
  }
  yg(event) {
    this.oa = event.touches[0].clientX;
  }
  zg(event) {
    if (isNull(this.oa))
      return;
    event.preventDefault();
    if (this.$store.dragging())
      return;
    const diff = event.touches[0].clientX - this.oa;
    if (Math.abs(diff) > 20) {
      this.oa = event.touches[0].clientX;
      this.La = this.$store.value();
      this.nc(this.La, event);
    }
  }
  vg() {
    if (this.g.p())
      return;
    this.listen("focus", this.Sa.bind(this));
    this.listen("pointerenter", this.Kb.bind(this));
    this.listen("pointermove", this.Ag.bind(this));
    this.listen("pointerleave", this.Lb.bind(this));
    this.listen("pointerdown", this.Bg.bind(this));
    this.listen("keydown", this.Za.bind(this));
    this.listen("keyup", this.Ya.bind(this));
  }
  wg() {
    if (this.g.p() || !this.$store.dragging())
      return;
    listenEvent(document, "pointerup", this.Cg.bind(this));
    listenEvent(document, "pointermove", this.Dg.bind(this));
    if (IS_SAFARI) {
      listenEvent(document, "touchmove", this.Eg.bind(this), {
        passive: false
      });
    }
  }
  Sa() {
    this.ca(this.$store.value());
  }
  oc(newValue, trigger) {
    const { value, min, max, dragging } = this.$store;
    const clampedValue = Math.max(min(), Math.min(newValue, max()));
    value.set(clampedValue);
    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
    this.el.dispatchEvent(event);
    this.g.pc(event);
    if (dragging()) {
      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
      this.el.dispatchEvent(event2);
      this.g.qc(event2);
    }
  }
  ca(value, trigger) {
    const { pointerValue, dragging } = this.$store;
    pointerValue.set(value);
    this.dispatch("pointer-value-change", { detail: value, trigger });
    if (dragging()) {
      const dir = this.g.J === "vertical" ? "bottom" : "left", size = this.g.J === "vertical" ? "height" : "width";
      if (this.Ma && !this.el?.hasAttribute("data-chapters")) {
        this.Ma.style[size] = value + "%";
      }
      if (this.pa) {
        this.pa.style[dir] = value + "%";
      }
      this.oc(value, trigger);
    }
  }
  zb(event) {
    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$store;
    if (this.g.J === "vertical") {
      const { bottom: trackBottom, height: trackHeight } = rect;
      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
    } else {
      if (this.oa && isNumber(this.La)) {
        const { width } = this.Ka.getBoundingClientRect(), rate = (event.clientX - this.oa) / width, range = max() - min(), diff = range * Math.abs(rate);
        thumbPositionRate = (rate < 0 ? this.La - diff : this.La + diff) / range;
      } else {
        const { left: trackLeft, width: trackWidth } = rect;
        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
      }
    }
    return Math.max(
      min(),
      Math.min(
        max(),
        this.g.Wd(
          getValueFromRate(min(), max(), thumbPositionRate, this.g.Ab())
        )
      )
    );
  }
  Kb(event) {
    this.$store.pointing.set(true);
  }
  Ag(event) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    this.ca(this.zb(event), event);
  }
  Lb(event) {
    this.$store.pointing.set(false);
  }
  Bg(event) {
    if (event.button !== 0)
      return;
    const value = this.zb(event);
    this.nc(value, event);
    this.ca(value, event);
  }
  nc(value, trigger) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    dragging.set(true);
    this.pa = this.el.querySelector(
      'shadow-root > div[part="thumb-container"]'
    );
    this.Ma = this.el.querySelector(
      'shadow-root > div[part~="track-fill"]'
    );
    this.a.remote.pauseUserIdle(trigger);
    const event = this.createEvent("drag-start", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.g.Xd(event);
  }
  Yd(value, trigger) {
    const { dragging } = this.$store;
    if (!dragging())
      return;
    dragging.set(false);
    if (this.Ma) {
      setStyle(this.Ma, "width", null);
      this.Ma = null;
    }
    if (this.pa) {
      setStyle(this.pa, "left", null);
      setStyle(this.pa, "bottom", null);
      this.pa = null;
    }
    this.a.remote.resumeUserIdle(trigger);
    const event = this.createEvent("drag-end", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.g.rc(event);
    this.oa = null;
    this.La = null;
  }
  Za(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key } = event;
    const { min, max } = this.$store;
    let newValue;
    if (key === "Home" || key === "PageUp") {
      newValue = min();
    } else if (key === "End" || key === "PageDown") {
      newValue = max();
    } else if (!event.metaKey && /[0-9]/.test(key)) {
      newValue = (max() - min()) / 10 * Number(key);
    }
    if (!isUndefined(newValue)) {
      this.ca(newValue, event);
      this.oc(newValue, event);
      return;
    }
    const value = this.Zd(event);
    if (!value)
      return;
    const repeat = key === this.sc;
    if (!this.$store.dragging() && repeat)
      this.nc(value, event);
    this.ca(value, event);
    if (!repeat)
      this.oc(value, event);
    this.sc = key;
  }
  Ya(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    this.sc = "";
    const { dragging, value } = this.$store;
    if (!dragging())
      return;
    const newValue = this.Zd(event) ?? value();
    this.ca(newValue);
    this.Yd(newValue, event);
  }
  Zd(event) {
    const { key, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key);
    if (!isValidKey)
      return;
    const { shiftKeyMultiplier } = this.$props;
    const { value } = this.$store, step = this.g.Ab(), keyStep = this.g._d();
    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, steps = (value() + diff) / step;
    return Number((step * steps).toFixed(3));
  }
  // -------------------------------------------------------------------------------------------
  // Document (Pointer Events)
  // -------------------------------------------------------------------------------------------
  Cg(event) {
    if (event.button !== 0)
      return;
    const value = this.zb(event);
    this.ca(value, event);
    this.Yd(value, event);
  }
  Eg(event) {
    event.preventDefault();
  }
};

// src/player/ui/sliders/slider/slider.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><div part="track"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-fill"></div>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-progress"></div>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<!$><div part="thumb-container"><!$><div part="thumb"></div></div>`);
var Slider = class extends Component {
  constructor(instance) {
    super(instance);
    this.tc = false;
    this.J = "";
    // -------------------------------------------------------------------------------------------
    // Preview
    // -------------------------------------------------------------------------------------------
    this.Q = null;
    provideContext(sliderValueFormatContext);
    this.a = useMedia();
    new SliderEventsController(instance, this, this.a);
    const focus = new FocusVisibleController(instance);
    this.$store.focused = focus.focused.bind(focus);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "role", "slider");
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(el, "autocomplete", "off");
    this.J = el.getAttribute("aria-orientation") || "";
    if (!this.tc) {
      effect(this.Fg.bind(this));
      effect(this.uc.bind(this));
    }
    effect(this.vc.bind(this));
    this.Gg();
  }
  onConnect(el) {
    this.Hg();
  }
  render() {
    const { trackClass, trackFillClass, trackProgressClass, thumbContainerClass, thumbClass } = this.$props;
    return [
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ);
        $$_effect(() => $$_attr($$_root, "class", trackClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
        $$_effect(() => $$_attr($$_root, "class", trackFillClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_3);
        $$_effect(() => $$_attr($$_root, "class", trackProgressClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_4), $$_el = $$_next_element($$_walker);
        $$_effect(() => $$_attr($$_root, "class", thumbContainerClass()));
        $$_effect(() => $$_attr($$_el, "class", thumbClass()));
        return $$_root;
      })()
    ];
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  Ab() {
    return this.$props.step();
  }
  _d() {
    return this.$props.keyStep();
  }
  Wd(value) {
    return Math.round(value);
  }
  p() {
    return this.$props.disabled();
  }
  // -------------------------------------------------------------------------------------------
  // Watch
  // -------------------------------------------------------------------------------------------
  Fg() {
    const { min, max } = this.$props;
    this.$store.min.set(min());
    this.$store.max.set(max());
  }
  uc() {
    if (!this.p())
      return;
    const { dragging, pointing } = this.$store;
    dragging.set(false);
    pointing.set(false);
  }
  vc() {
    const { dragging, value, min, max } = this.$store;
    if (peek(dragging))
      return;
    value.set(getClampedValue(min(), max(), value(), this.Ab()));
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  Ig() {
    return ariaBool(this.p());
  }
  wc() {
    return this.$props.min();
  }
  xc() {
    return this.$props.max();
  }
  Jg() {
    const { value } = this.$store;
    return Math.round(value());
  }
  $d() {
    const { value, max } = this.$store;
    return round(value() / max() * 100, 2) + "%";
  }
  // -------------------------------------------------------------------------------------------
  // Attributes
  // -------------------------------------------------------------------------------------------
  Gg() {
    const { disabled } = this.$props, { dragging, fillPercent, interactive, pointerPercent, pointing } = this.$store;
    this.setAttributes({
      disabled,
      "data-dragging": dragging,
      "data-pointing": pointing,
      "data-interactive": interactive,
      "aria-disabled": this.Ig.bind(this),
      "aria-valuemin": this.wc.bind(this),
      "aria-valuemax": this.xc.bind(this),
      "aria-valuenow": this.Jg.bind(this),
      "aria-valuetext": this.$d.bind(this),
      "data-styled": this.Kg.bind(this),
      "data-media-slider": true
    });
    this.setCSSVars({
      "--slider-fill-percent": () => round(fillPercent(), 3) + "%",
      "--slider-pointer-percent": () => round(pointerPercent(), 3) + "%"
    });
  }
  Kg() {
    return !!this.$props.trackClass();
  }
  Hg() {
    this.Q = this.el.querySelector('[slot="preview"]');
    if (!this.Q)
      return;
    effect(this.Lg.bind(this));
    import('./preview-JJG3ZTKT.js').then(({ setupPreviewStyles }) => {
      setupPreviewStyles(this.Q, this.J);
    });
  }
  Lg() {
    if (this.p() || !this.Q)
      return;
    const onResize = this.Mg.bind(this);
    window.requestAnimationFrame(onResize);
    const observer = new ResizeObserver(onResize);
    observer.observe(this.Q);
    return () => observer.disconnect();
  }
  Mg() {
    if (!this.Q)
      return;
    const rect = this.Q.getBoundingClientRect();
    setStyle(this.Q, "--computed-width", rect.width + "px");
    setStyle(this.Q, "--computed-height", rect.height + "px");
  }
  // -------------------------------------------------------------------------------------------
  // Events
  // -------------------------------------------------------------------------------------------
  pc(event) {
  }
  Xd(event) {
  }
  rc(event) {
  }
  qc(event) {
  }
};
Slider.el = defineElement({
  tagName: "media-slider",
  props: sliderProps,
  store: SliderStoreFactory
});

export { Slider, sliderProps };
